---
title: An automatically created novel bug dataset and its validation in bug prediction
---
## アブストラクト
- ソフトウェア開発においては、頻繁なコード変更や厳しい納期などにより、バグの発生は避けられない
- そのため、このミスを見つけるためのツールが不可欠
- バグを特定する1つの方法としては、過去のバグのあるソースコード要素の特性を分析し、同じ特性に基づいて現在のバグを予測することがある
- BugHunterデータセットを紹介
	- ファイル、クラス、メソッドからなるコード要素、幅広いコードメトリクス、バグ情報を含む自動で構築されたバグデータセット
- 既存のバグデータセットでは、事前に選ばれたリリースバージョンにおけるすべてのソースコード要素の特性が収集されていた
- BugHunterデータセットは、バグの存在を特定できる最も狭い期間において、同じソースコード要素のバグあり状態と修正済み状態を捉える
- 新しいデータセットは、バグ予測モデルにおいてF1スコア0.74を達成
## はじめに
- バグのあるソースコード要素の特性評価は近年注目されている研究分野である
- 未知の欠陥のあるコード要素を識別するには既知の欠陥のあるコード要素の特性評価が必要
- ソフトウェア開発においてプログラマーはバグ追跡、タスク管理、バージョン管理システムなどの様々なツールを使用
- これらのツールのほとんどにバグ追跡機能が含まれているため、この情報を使用してバグのあるソースコードの特徴付けを行える
	- 実際に特徴付けを行うには、ソースコードのホスティングプロバイダーが管理しているバグレポートを適切なソースコードに関連付ける必要がある
	- コミットメッセージに含まれるバグレポートのリンクを使用することで、問題のあるソースコードが追加されたバージョンを特定できる
- バグのあるコードの特性に関する有用な情報を含むデータセットを構築するために、GitHubを選択した
	- GitHubには、定期的にメンテナンスされている複数のプロジェクトがホストされており、自動データ取得ツールを実装するためのAPIも備わっているため
- 対象システムとして15のJavaプロジェクトを選択した
	- これらのプロジェクトは、規模、ドメイン、報告されたバグの数などの様々な点で互いに異なる
- これまでに公開されたデータセットはには、分析対象システムの1つ以上のバージョンからのすべてのコード要素（バグのあるものとないものの両方）が含まれる
- 本研究では、バグの影響を受けたコード要素とその特性の修正前と修正後のスナップショットを収集し、バグの影響を受けなかったコード要素は考慮しないという新しいアプローチを作成した
- このデータセットは、バグ修正時のコードメトリクスの変化を捉えるのに役立つ
- 新しいデータセットはBugHunter Datasetと呼ばれ、無料で入手できる
- この新しいデータセットがバグ予測に適しているかどうかを確認するための実験も行った
## 関連研究#
### バグの特定とソースコード管理
- バグの特性評価と位置特定については、多くのアプローチが発表されている
	- BugLocator: バグレポートとソースコードの間のテキストの類似性を使用して問題が発生しやすいファイルをランク付け
	- ReLink: バージョン管理システムでコミットされたコード変更と修正されたバグとの間の関連性を探索
- これらのツールは、SZZアルゴリズムを使用して要る
	- SZZアルゴリズムはファイルレベルのテキストの特徴を使用してバグとソースコードの間の追加情報を抽出
- バグ追跡システムによって管理されるバグレポートを使用して、ソフトウェアシステム内のバグのあるファイルを迅速に見つける方法が紹介された
### 公開データセット
- PROMISE: オープンソースやクローズドソースの産業用ソフトウェアシステムから収集されたバグが含まれている
- Bug prediction dataset: クラスとバグを関連付けている
- iBUGS: 自動的にソフトウェアの欠陥位置を特定する方法をテストするための環境を提供
- Bugcatchers: 対象システムで検出されたバグとコードの臭いを含んでいる
- ELFF: メソッドレベルのデータセット
- Had-oops!: 連続する8つのHadoopのバージョンを分析し、時系列が欠陥予測のパフォーマンスに与える影響を調査
## データソース
### GitHub
- 最も人気のあるソースコードホスティングサービスの1つ
- バグ追跡システム、イシュー追跡システムなどの共同作業支援サービスも提供
- レポートにバグラベルを追加するとバグレポートとして分類でき、コミットメッセージからバグレポートのIDを参照することでバグとイシューを関連付けられる
- GitHubには、他のシステムのリポジトリを管理したり、それらに関する情報を調べたりするために使用できるAPIがある
### 選ばれたプロジェクト
- Javaで書かれている
- 規模が大きい
- バグとしてラベル付けされたイシューの数が十分である
- コミットメッセージから特定のバグ混入コミットを参照している
- 現在も積極的にメンテナンスされている
- スターとウォッチの数の合計を人気度と定義し、人気度を参考にした
- 選択されたプロジェクト
	- Android Universal Image Loader
		- [https://github.com/nostra13/Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader)
	- ANTLR v4
		- [https://github.com/antlr/antlr4](https://github.com/antlr/antlr4)
	- Elasticsearch
		- [https://github.com/elastic/elasticsearch](https://github.com/elastic/elasticsearch)
	- MapDB
		- [https://github.com/jankotek/MapDB](https://github.com/jankotek/MapDB)
	- mcMMO
		- [https://github.com/mcMMO-Dev/mcMMO](https://github.com/mcMMO-Dev/mcMMO)
	- Mission Control Technologies
		- [https://github.com/nasa/mct](https://github.com/nasa/mct)
	- Neo4j
		- [https://github.com/neo4j/neo4j](https://github.com/neo4j/neo4j)
	- Netty
		- [https://github.com/netty/netty](https://github.com/netty/netty)
	- OrientDB
		- [https://github.com/orientechnologies/orientdb](https://github.com/orientechnologies/orientdb)
	- Oryx 2
		- [https://github.com/OryxProject/oryx](https://github.com/OryxProject/oryx)
	- Titan
		- [https://github.com/thinkaurelius/titan](https://github.com/thinkaurelius/titan)
	- Eclipse plugin for Ceylon
		- [https://github.com/eclipse/ceylon-ide-eclipse](https://github.com/eclipse/ceylon-ide-eclipse)
	- Hazelcast
		- [https://github.com/hazelcast/hazelcast](https://github.com/hazelcast/hazelcast)
	- Broadleaf Commerce
		- [https://github.com/BroadleafCommerce/BroadleafCommerce](https://github.com/BroadleafCommerce/BroadleafCommerce)
## メトリクス
- ソフトウェアメトリクスは、ソフトウェアプロジェクトの特性を定量化した指標
- この研究では静的コードメトリクス（ソフトウェア製品メトリクス）を使用
- OpenStaticAnalyzerを使用して、選択されたシステムの様々なソフトウェア製品メトリクスを取得
	- https://github.com/sed-inf-u-szeged/OpenStaticAnalyzer
## データセットの作成
### データの収集
- GitHub APIを介して、選択したプロジェクトに関するデータを保存
- 保存するデータには、リポジトリに割り当てられたユーザー（コントリビューター）のリスト、未解決および解決済みのバグレポート（イシュー）、全てのコミットが含まれる
- 未解決のイシューについては、作成日のみを保存
- 解決済みのイシューについては、作成日、解決日、修正コミットのハッシュとそのコミット日を保存
- どのコミットからも参照されていない解決済みのバグは保存しなかった
- GitHubのイシューに関連付けられるラベルに基づいて、これらのフィルタリングを行った
- 保存したコミットに関するデータには、コントリビューターのID、親コミット、影響を受けるファイルとそれに対応する変更が含まれる
- これらの生の情報は、次の処理の入力として使用するために全てXML形式で保存された
### 生データの処理
- GitHubから保存されたデータには全てのコミットが含まれているが、この研究ではバグレポートに関連するコミットだけが必要
- データセットを構築するには、バグ修正コミットを適用する直前のコミットIDとバグを修正するコミットIDが必要
	- コミットメッセージだけでなく、バグレポートからも、バグ修正コミットを適用する直前のコミットIDとバグを修正するコミットIDを取得
### ソースコード解析
- それぞれのコミットIDに対応するコミットのソースコードを収集し、OpenStaticAnalyzerでコードメトリクス（特徴量）を抽出
### バグの数の抽出
- コード分析の結果とGitHubから収集したデータの2つのデータセットを関連付け、バグの特徴を抽出
- 影響を受けるソースコードを特定するために、SZZアルゴリズムに似たアプローチが用いられた
	- GitHubデータから保存したdiffファイルを使用し、変更された全てのファイルのソースコードを調べ、どのコード要素が変更によって影響を受けるかを特定
	- OpenStaticAnalyzerのソース行マッピングという機能を使用
- 「生データの処理」ステップで選択されたコミットを取得し、これらのコミット内のバグの影響を受けたコード領域をマークするために、その要素の完全修飾名を収集
- 特定のバージョンのソースコード要素に複数の問題がマークされている場合、そのバージョンには複数のバグが含まれている
### CSVファイルの結合
- OpenStaticAnalyzerのCSV出力とそれ以外のCSV出力を結合
### フィルタリング
- データセットには、さらなる調査を複雑にする様々なエントリーが含まれている可能性がある
	- データセットには、同じメトリック値を持ちながら、異なる数のバグが割り当てられているエントリーが存在する可能性がある
- 異なるバグを持つ異なるメソッド$M_{f_1}$と$M_{f_2}$、バグが修正された異なるメソッドド$M_{g_1}$と$M_{g_2}$を考えたときに、メトリック値において$M_{f_1} = M_{f_2}$あるいは$M_{g_1} = M_{g_2}$であった場合、バグ予測のための機会学習の精度に悪い影響を与える冗長性が生まれる
- この問題を解決するために、生のデータセットをフィルタリングして冗長なエントリーを排除するための、異なるアプローチを使用
	- Removal: より大きなエントリー数を持つクラスにあるエントリーを保持
	- Subtract: より大きなエントリー数を持つクラスのエントリーを、より小さなエントリー数を持つクラスのエントリー数と同じ数だけ削除
	- Single: より小さなエントリー数を持つクラスのエントリーを削除し、より大きなエントリー数を持つクラスは1つのエントリーのみを保持
	- GCF: 両方のクラスのエントリー数をそれらの最大公約数または最大公約除数で割り、その結果として得られる数のエントリーのみをそれぞれのクラスが保持
- フィルタリング手法ごとの評価では、Removal法のF1スコアが最も高かった
### 分類と再サンプリング
- バグの存在を示すフラグを予測することに研究を限定した
	- 分類アルゴリズムを適用
	- 2値分類を行うために、バグが0のインスタンスを「バグなし」クラスに、バグが1つ以上あるインスタンスを「バグあり」に分類
	- 不均衡データによる予測精度の低下を防ぐためにRandom Under Samplingを使用し、それぞれのカテゴリーから同数のデータを取得
### BugHunterデータセット
- 主な貢献として、ファイル、クラス、メソッドの各レベルでソースコード要素の修正前後の状態を含む新しい種類のバグデータセットを構築した
### 検証
- JUnitプロジェクトのデータセットを検証
- このプロジェクトには、クローズされたバグレポートが84件あり、データセットにはそのうちの37件が含まれている
	- これは、多くの修正コミットがソースコードやJavaコードに関連していないため
- JUnitプロジェクトのエントリーのおよそ1%が不適切であった
### ファイルとクラスの関係
- Javaの場合は、通常、.javaファイルごとに1つのクラスが存在
- 実際に対象プロジェクからランダムに100個のコミットを選択し、分析対象ファイルに含まれるクラス数を数えたところ、ほとんどのファイルは1つのクラスのみを含んでいるが、複数のクラスを含むファイルもある程度存在した
- この結果から、1つのファイルを1つのクラスに関連付けることはできないことが分かった
### データセット拡張の計算コスト
- データセットの拡張には計算コストがかかる
- データセットに新しいプロジェクトを追加するには、そのプロジェクトがバグレポートとバグ修正コミットを持っている必要がある
	- このようなプロジェクトを見つける作業は手動で行うため、時間がかかる
- 最も重要なステップは、適切なバグを収集すること
- GitHubには1時間あたりのAPIリクエスト数に制限があったため、バグ収集に時間がかかった
- 最も時間とリソースを消費する作業は、ソースコード分析
- OpenStaticAnalyzerは深い静的分析を実行するため、単純なパーサーツールよりも多くのリソースが必要
## 評価
- 
## 引用情報
- 著者: Rudolf Ferenc, Péter Gyimesi, Gábor Gyimesi, Zoltán Tóth, Tibor Gyimóthy
- タイトル: An automatically created novel bug dataset and its validation in bug prediction
- 雑誌 / 会議名: Journal of Systems and Software
- 巻号: vol. 169
- ページ: p. 110691
- 出版日: November 2020
- DOI: https://doi.org/10.1016/j.jss.2020.110691
